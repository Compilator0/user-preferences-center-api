import * as authentication from '@feathersjs/authentication';
import { HookContext } from '@feathersjs/feathers';
//import an utility function from didomi's JS tools
import { generateUserUUIDv1, emailIsValid } from './../../utils/didomi.jstools';
// Don't remove this comment. It's needed to format import lines nicely.


const { authenticate } = authentication.hooks;

/*
  An anonymous function that will modify the data in the Hook context in order to add the user's UUID
  to the User's data to be stored; It will be called before every create request on Users service
*/
const addUUIDFieldOnUserData = () => {
  return async (context: HookContext) => {
    const { data } = context;
    //Generate a v1 UUID to insert in the database
    const newUUID = generateUserUUIDv1();
    // Merge the context's data content to include the user's UUID generated by our function
    context.data = {
      ...data,
      'id' : newUUID
    }; 
    //return the context as best practice
    return context;
  }
} 

/*
  User's email validity control at the business layer. 
  If the email has an invalid email structure then an error is thrown;
*/
const controlsUsersEmailValidity = () => {
  return async (context: HookContext) => {
      const { data } = context;
      if( !emailIsValid(data.email) ) {
        throw new Error("The user's email is not a valid email");
      }
      return context;
    }
}

/*
  User's email unicity control at the business layer. 
  If the email already exist then an error is thrown;
*/
const controlsUsersEmailUnicity = () => {
  return async (context: HookContext) => {
    //we obtain the app and the user's data from the Hook context
    const { app, data, params } = context;
    //We use the user REST service to obtain the list of users in database 
    const listOfUser = await app.service('users').find(params);
    if(listOfUser.data){
      if(listOfUser.data.length > 0){
        if(listOfUser.data.some( (user: any) => user.email === data.email )){
          throw new Error("This email is already used, please change it.");
        }
      }
    }
    
    return context;
  }
} 


/*
  An anonymous function that will build the Outgoing user consent data into the format of this exercice
  It will be called after and applied on every User service request result 
*/
const consentStateBuilder =  () => {
  return async (context: HookContext) => {
    // Get `app`, `method` and `result` from the hook context
    const { app, method, result } = context;

    // Function that adds it consent's data to every user returned by the get from Users REST API
    const buildConsentState = async (currentUser: any) => {
        // I get the user consent state by using a specific function designed in Users Class 
        const consentState = await app.service('users').getUserConsentState(currentUser.id);
        console.log('llllllllllllllllllllllllllllllllllllll');
        console.log(consentState);
      // Add the user consent last state to the current user data, to globally form the famous user consent state 
        return consentState;
    };
    
   if (method === 'find') {
      // Map all Users data to build Users consent state 
      context.result.data = await Promise.all(result.data.map(buildConsentState));
    } else {
      // Otherwise just update the single result
      context.result = await buildConsentState(result);
    } 
    // We return the hook context
    return context;
  }

}


export default {
  before: {
    all: [ authenticate('jwt') ],
    find: [],
    get: [],
    create: [ addUUIDFieldOnUserData(), controlsUsersEmailValidity(), controlsUsersEmailUnicity() ],
    update: [],
    patch: [],
    remove: []
  },

  after: {
    all: [ consentStateBuilder() ],
    find: [],
    get: [],
    create: [ ],
    update: [],
    patch: [],
    remove: []
  },

  error: {
    all: [],
    find: [],
    get: [],
    create: [],
    update: [],
    patch: [],
    remove: []
  }

};
