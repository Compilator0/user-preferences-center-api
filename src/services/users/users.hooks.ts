import * as authentication from '@feathersjs/authentication';
import { HookContext } from '@feathersjs/feathers';
//import an utility function from didomi's JS tools
import { generateUserUUIDv1, emailIsValid, renameKey, deleteObjectFields } from './../../utils/didomi.jstools';
// Don't remove this comment. It's needed to format import lines nicely.


const { authenticate } = authentication.hooks;


/*
  An anonymous function that will modify the data in the Hook context in order to add the user's UUID
  to the User's data to be stored; It will be called before every create request on Users service
*/
const addUUIDFieldOnUserData = () => {
  return async (context: HookContext) => {
    const { data } = context;
    console.log('llllllllllllllllllllllllllllllllllllll');
    console.log(data);
    //Generate a v1 UUID to insert in the database
    const newUUID = generateUserUUIDv1();
    // Merge the context's data content to include the user's UUID generated by our function
    context.data = {
      ...data,
      'uuid' : newUUID
    }; 
    //return the context as best practice
    return context;
  }
} 

/*
  User's email validity control at the business layer. 
  If the email has an invalid email structure then an error is thrown;
*/
const controlsUsersEmailValidity = () => {
  return async (context: HookContext) => {
      const { data } = context;
      if( !emailIsValid(data.email) ) {
        throw new Error("The user's email is not a valid email");
      }
      return context;
    }
}

/*
  User's email unicity control at the business layer. 
  If the email already exist then an error is thrown;
*/
const controlsUsersEmailUnicity = () => {
  return async (context: HookContext) => {
    //we obtain the app and the user's data from the Hook context
    const { app, data, params } = context;
    //We use the user REST service to obtain the list of users in database 
    const listOfUser = await app.service('users').find(params);
    if(listOfUser.data){
      if(listOfUser.data.length > 0){
        if(listOfUser.data.some( (user: any) => user.email === data.email )){
          throw new Error("This email is already used, please change it.");
        }
      }
    }
    
    return context;
  }
} 


/*
  An anonymous function that will build the Outgoing user consent state result into the format of this exercice
  It will be called after after every User service request result 
*/
const consentStateBuilder =  () => {
  return async (context: HookContext) => {
    // Get `app`, `method` and `result` from the hook context
    const { app, method, result } = context;
    // Function that adds it consent's data to every user returned by the get from Users REST API
    const buildConsentState = async (currentUser: any) => {
        // I get the user consent state by using a specific function designed in Users Class 
        let consentState = await app.service('users').getUserConsentState(currentUser.uuid);
        console.log('ooooooooooooooooooooooo');
        console.log(consentState);
        consentState = deleteObjectFields(consentState, 'uuid');
        console.log('rrrrrrrrrrrrrrrrrrrrrrr');
        console.log(consentState);
      // Add the user consent last state to the current user data, to globally form the famous user consent state 
        return consentState;
    };
    
    if (method === 'find') {
      console.log('zzaarbirrrrrrrrrrrrrrrrrrrrr');
      console.log(result);
      // Map all Users from database to build Users consent state 
      context.result = await Promise.all(result.data.map(buildConsentState));
    } else {
      console.log('wzaarbirrrrrrrrrrrrrrrrrrrrr');
      console.log(result);
      // Otherwise just update the single result
      context.result = await buildConsentState(result);
    } 
    console.log('lafinwzaarbirrrrrrrrrrrrrrrrrrrrr');
    console.log(context.result);
    // We return the hook context
    return context;
  }

}


export default {
  before: {
    all: [ authenticate('jwt') ],
    find: [],
    get: [],
    create: [ 
      addUUIDFieldOnUserData(), 
      controlsUsersEmailValidity(), 
      controlsUsersEmailUnicity() 
    ],
    update: [
      controlsUsersEmailValidity(), 
      controlsUsersEmailUnicity() 
    ],
    patch: [
      controlsUsersEmailValidity(), 
      controlsUsersEmailUnicity() 
    ],
    remove: []
  },

  after: {
    all: [ consentStateBuilder() ],
    find: [],
    get: [],
    create: [ ],
    update: [],
    patch: [],
    remove: []
  },

  error: {
    all: [],
    find: [],
    get: [],
    create: [],
    update: [],
    patch: [],
    remove: []
  }

};

