import * as authentication from '@feathersjs/authentication';
import { HookContext } from '@feathersjs/feathers';
import { UserExistingEmail } from '../../errors/users/user.existing.email.error';
import { UserInvalidEmail } from '../../errors/users/user.invalid.email.error';
import { emailIsValid, generateUserUUIDv1, deleteObjectFields, renameKey } from '../../utils/didomi.jstools';
//import an utility function from didomi's JS tools

// Don't remove this comment. It's needed to format import lines nicely.

const { authenticate } = authentication.hooks;

/*
  An anonymous function that will modify the data in the Hook context in order to add the user's UUID
  to the User's data to be stored; It will be called before every create request on Users service
*/
const addUUIDFieldOnUserData = () => {
  return async (context: HookContext) => {
    const { data } = context;
    //Generate a v1 UUID to insert in the database
    const newUUID = generateUserUUIDv1();
    // Merge the context's data content to include the user's UUID generated by our function
    context.data = {
      ...data,
      'uuid' : newUUID
    }; 
    //return the context as best practice
    return context;
  }
} 

/*
  User's email validity control at the business layer. 
  If the email has an invalid email structure then an error is thrown;
*/
const controlsUsersEmailValidity = () => {
  return async (context: HookContext) => {
      const { data } = context;
      if( !emailIsValid(data.email) ) {
          throw new UserInvalidEmail("The user's email is not a valid email", data.email);
      }
      return context;
    }
}

/*
  User's email unicity control at the business layer. 
  If the email already exist then an error is thrown;
*/
const controlsUsersEmailUnicity = () => {
  return async (context: HookContext) => {
    //we obtain the app and the user's data from the Hook context
    const { app, data, params } = context;
    //We use the user REST service to obtain the list of users in database 
    const listOfUser = await app.service('users').find(params);
    if(listOfUser.data){
        if(listOfUser.data.length > 0){
          console.log(context);
          if(listOfUser.data.some( (user: any) => user.email === data.email )){
               throw new UserExistingEmail("This email is already used, please change it.", data.email);
          }
        }
    }
    return context;
  }
} 

/*
  A function that will build the Outgoing user consent state into the format of this exercice
  It will be called "after" every a User service request to ensure the user is returned in the format needed 
*/
const consentStateBuilder =  () => {

  return async (context: HookContext) => {
    // Get `app`, `method` and `result` from the hook context
    const { app, method, result } = context;

    // Function that adds the user consent state on every user returned by the find service of Users REST API
    const buildConsentState = async (currentUser: any) => {
        // I get the user consent state by fetching the last event registered for each of his consent 
        // I've designed a specific function for this stuff at the Users Class service Level : getUserConsentState(userUuid)
        let consentState = await app.service('users').getUserConsentState(currentUser.uuid);
        // Adding an array of consents to the current User
        currentUser.consents = [];
        consentState.forEach( (currentConsent: any) => {
            currentUser.consents.push(currentConsent);
        });
        // Renaming the uuid field of the current User to match the field name to be displayed 
        // and adding it as the first field of the object to return
        currentUser = renameKey(currentUser, 'uuid', 'id');
        currentUser = {
          id: currentUser.id,
          ...currentUser
        };
        console.log('cresultqEndENdpreaftereqsqsazzzzzzeeeeeeeeeeeeeeeeeeeeeeeeee')
        console.log(currentUser); 
        // Removing from the current user, fields that should not be displayed
        currentUser = deleteObjectFields(currentUser, 'createdAt', 'updatedAt');
        // Removing limit_event_history field from user's consents
        currentUser.consents.map( (consent: any) => deleteObjectFields(consent, 'limit_event_history'));
        //The current user is then returned with his famous consent state (array of his last consents relative to each type of consent (email_notification, sms_notification, ...)))
        return currentUser;
   };
   
   if (method === 'find') {
        if(result.data){
             if(result.data.length > 0){
                 // Map all Users from database to build Users consent state 
                  context.result = await Promise.all(result.data.map(buildConsentState));
              }
        }
   } else {
        //Otherwise just update the single result
        context.result = await buildConsentState(result);
   } 
   // We return the hook context
   return context;
 }

}


export default {
  before: {
    all: [ authenticate('jwt') ],
    find: [],
    get: [],
    create: [ 
      addUUIDFieldOnUserData(), 
      controlsUsersEmailValidity(), 
      controlsUsersEmailUnicity() 
    ],
    update: [
      controlsUsersEmailValidity(), 
      controlsUsersEmailUnicity() 
    ],
    patch: [
      controlsUsersEmailValidity(), 
      controlsUsersEmailUnicity() 
    ],
    remove: []
  },

  after: {
    all: [ consentStateBuilder() ],
    find: [],
    get: [],
    create: [ ],
    update: [],
    patch: [],
    remove: []
  },

  error: {
    all: [],
    find: [],
    get: [],
    create: [],
    update: [],
    patch: [],
    remove: []
  }

};

