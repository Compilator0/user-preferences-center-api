import * as authentication from '@feathersjs/authentication';
import { HookContext } from '@feathersjs/feathers';
import { UserExistingEmail } from '../../errors/users/user.existing.email.error';
import { UserInvalidEmail } from '../../errors/users/user.invalid.email.error';
import { emailIsValid, generateUserUUIDv1, deleteObjectFields, renameKey } from '../../utils/didomi.jstools';
//import an utility function from didomi's JS tools

// Don't remove this comment. It's needed to format import lines nicely.

const { authenticate } = authentication.hooks;

/*
  An anonymous function that will modify the data in the Hook context in order to add the user's UUID
  to the User's data to be stored; It will be called before every create request on Users service
*/
const addUUIDFieldOnUserData = () => {
  return async (context: HookContext) => {
    const { data } = context;
    //Generate a v1 UUID to insert in the database
    const newUUID = generateUserUUIDv1();
    // Merge the context's data content to include the user's UUID generated by our function
    context.data = {
      ...data,
      'uuid' : newUUID
    }; 
    //return the context as best practice
    return context;
  }
} 

/*
  User's email validity control at the business layer. 
  If the email has an invalid email structure then an error is thrown;
*/
const controlsUsersEmailValidity = () => {
  return async (context: HookContext) => {
      const { data } = context;
      if( !emailIsValid(data.email) ) {
          throw new UserInvalidEmail("The user's email is not a valid email", data.email);
      }
      return context;
    }
}

/*
  User's email unicity control at the business layer. 
  If the email already exist then an error is thrown;
*/
const controlsUsersEmailUnicity = () => {
  return async (context: HookContext) => {
    //we obtain the app and the user's data from the Hook context
    const { app, data, params } = context;
    //We use the user REST service to obtain the list of users in database 
    const listOfUser = await app.service('users').find(params);
    if(listOfUser.data){
        if(listOfUser.data.length > 0){
          console.log(context);
          if(listOfUser.data.some( (user: any) => user.email === data.email )){
               throw new UserExistingEmail("This email is already used, please change it.", data.email);
          }
        }
    }
    return context;
  }
} 

/*
  An anonymous function that will build the Outgoing user consent state into the format of this exercice
  It will be called after after every User service request result to ensure the user is returned in the format needed 
*/

const consentStateBuilder =  () => {

  return async (context: HookContext) => {
    // Get `app`, `method` and `result` from the hook context
    const { app, method, result } = context;

    // Function that adds the user consent state on every user returned by the find service of Users REST API
    const buildConsentState = async (currentUser: any) => {
        // I get the user consent state by fetching the last event registered for each of his consent 
        // I've designed a specific function for this stuff at the User's Class service Level
        console.log('beforeqsqsazzzzzzeeeeeeeeeeeeeeeeeeeeeeeeee')
        console.log(currentUser);
        let consentState = await app.service('users').getUserConsentState(currentUser.uuid);
        console.log('qsqsazzzzzzeeeeeeeeeeeeeeeeeeeeeeeeee')
        console.log(consentState);
        currentUser.consents = [];
        // Adding an array of consents to the current User
        consentState.forEach( (currentConsent: any) => {
            currentUser.consents.push(currentConsent);
        });
        console.log('preaftereqsqsazzzzzzeeeeeeeeeeeeeeeeeeeeeeeeee')
        console.log(currentUser);
        // Renaming the uuid field of the current User to match the field name to be printed
        currentUser = renameKey(currentUser, 'uuid', 'id');
        currentUser = {
          id: currentUser.id,
          ...currentUser
        };
        // Removing from the current user fields that should be sent
        console.log('EndpreaftereEndqsqsazzzzzzeeeeeeeeeeeeeeeeeeeeeeeeee')
        console.log(currentUser);
        currentUser = deleteObjectFields(currentUser, 'createdAt', 'updatedAt');
       //The current user is then returned with his famous consent state (array of consents))
       console.log('EndENdpreaftereqsqsazzzzzzeeeeeeeeeeeeeeeeeeeeeeeeee')
       console.log(currentUser);
       return currentUser;
    };
   
   if (method === 'find') {
        if(result.data){
             if(result.data.length > 0){
                 // Map all Users from database to build Users consent state 
                  context.result = await Promise.all(result.data.map(buildConsentState));
              }
        }
   } else {
        //Otherwise just update the single result
        context.result = await buildConsentState(result);
   } 
   // We return the hook context
   return context;
 }

}


export default {
  before: {
    all: [ authenticate('jwt') ],
    find: [],
    get: [],
    create: [ 
      addUUIDFieldOnUserData(), 
      controlsUsersEmailValidity(), 
      controlsUsersEmailUnicity() 
    ],
    update: [
      controlsUsersEmailValidity(), 
      controlsUsersEmailUnicity() 
    ],
    patch: [
      controlsUsersEmailValidity(), 
      controlsUsersEmailUnicity() 
    ],
    remove: []
  },

  after: {
    all: [ consentStateBuilder() ],
    find: [],
    get: [],
    create: [ ],
    update: [],
    patch: [],
    remove: []
  },

  error: {
    all: [],
    find: [],
    get: [],
    create: [],
    update: [],
    patch: [],
    remove: []
  }

};

