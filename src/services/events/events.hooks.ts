import * as authentication from '@feathersjs/authentication';
import { Forbidden } from '@feathersjs/errors';
import { HookContext } from '@feathersjs/feathers';
import { ZeroEvent } from '../../errors/events/zero.event';
import { filterObjectFields } from '../../utils/didomi.jstools';
// Don't remove this comment. It's needed to format import lines nicely.

const { authenticate } = authentication.hooks;

let userOfInterest: any = null;

/*
  Controling the REST method to access the Event service
  According to the exercice we should not be able to update or delete envents
*/
const controlEnventServiceAcces = () => {

  return async (context: HookContext) => {
    const { method } = context;
    if (method === 'update' || method === 'patch'  || method === 'remove'){ 
      throw new Forbidden("This service forbidden !");
    }

    //returning the context as best practice
    return context;
  }
} 

/*
  Formating into the event's table format, the events information 
  and integrating them in the Hook context for further processing
*/
const buildEventsDataToPersit = () => {
  
  return async (context: HookContext) => {

    const { app, data, params } = context;
    userOfInterest = data;

    //Function that collects data needed for events insertion into the "association" table between User and Consent : the event table
    const buildEventToPersist = async (consent : any) => {

      //find the current consent's reel ID in the database
      const consentOfInterest = await app.service('consent').getConsentFromLabelAndDecision(consent.id, consent.enabled);

      //prepare the creation date of the event as recommended by the exercice
      const eventCreatedAt = new Date().getTime();
      //Building an event instance as it will be inserted accordingly to the "event" table structure.
      // An event Id will be generated by the database. 
      // A 'unique' constraint has been configure on the Sequelise schema of the table for the triplet of column (date, userUuid, consentId)
      
      return { 
          'createdAt': eventCreatedAt, 
          'userUuid': data.user.id, 
          'consentId': consentOfInterest.id,
          'uuid': data.user.id
      };
    }
    //The object listOfEventToPersist is to collect the list of event to persist in database for the current User
    let listOfEventToPersist : Array<any> = [];
    if(data.consents){
        if(data.consents.length > 0){
            listOfEventToPersist = await Promise.all( data.consents.map(buildEventToPersist) );
        }
        else{
            throw new ZeroEvent("At least one event is needed from the User", data);
        }
        context.data = listOfEventToPersist; 
    } 
    else{
        throw new ZeroEvent("No event has been sent by the User", data);
    }

    //returning the context as best practice
    return context;
  }
} 
 
  /*
    An anonymous function that will be called every time before returning the event data to the API's client
    It will be called after every create and get and find queries request on event service. 
  */
 const formatEventToRestore = () => {

    return async (context: HookContext) => {

        const { result, method, app } = context;
        console.log('eeeeeeeeeeeeeeeeeeeeeeeeeeeeeee')
        console.log(result);
        if(result === null){
          const consernedUser = userOfInterest;
        }

        //List of the users 
        const usersList = await app.service('users').find();
        console.log('Userseeeeeeeeeeeeeeeeeeeeeeeeeeeeeee')
        console.log(usersList);

        usersList.forEach( async (currentUser: any) => {
            //const listOfEvents = (await currentUser.getEvents()).toJSON();
            const eventsFormatedlist =  await app.service('consent').getFormatedEvent(currentUser.uuid);
            console.log('Eventseeeeeeeeeeeeeeeeeeeeeeeeeeeeeee')
            console.log(eventsFormatedlist);
        });
        
        // Function that formats an event to the client's API format
        const formatEventToReturn = async (currentEvent: any) => {
          // We find consents information of the event
          const consentOfInterest = (await app.service('events').find({
            query: {
              id: currentEvent.id,
              created_at: currentEvent.created_at
            }
          }));  

        console.log('azzzzzzeeeeeeeeeeeeeeeeeeeeeeeeee')
        console.log(consentOfInterest);
          if(result.data){
              if(result.data.length > 0){
                //Build the event Object as required by the API front-ent format
                  const eventFormated = {
                      'user': { 
                          id: currentEvent.user_uuid
                      },
                      'consents': {
                          //filterObjectFields function will delete from the object the unwanted filed
                          consentOfInterest: consentOfInterest.map(filterObjectFields(consentOfInterest))
                      }
                  };
                  console.log('bqqqqqqqqqqqqqqqeeeeeeeeeeeeeeeeeeeeeeeeee')
                  console.log(consentOfInterest);
                  return eventFormated;
              }
          }
          else{
              return {};
          }
        }
        if(method === 'find') {
          if(result.data){
              if(result.data.length > 0){
                  // Map on the list of consent data to build the consent data to return 
                  context.result = await Promise.all(result.data.map(formatEventToReturn));
              }
          }
        }
        else {
          // Otherwise just update the single result
          context.result = await formatEventToReturn(result);
        } 
    
        // We return the hook context
        return context;
    }
};

export default {
  before: {
    //All securized all web service with Jwt token
    //control the REST method before each incoming request, the exercice require not be let possible event update and delete
    all: [ authenticate('jwt'), controlEnventServiceAcces() ],
    find: [],
    get: [],
    //prepare our events data before storage into event table
    create: [ buildEventsDataToPersit() ],
    update: [],
    patch: [],
    remove: []
  },

  after: {
    all: [],
    find: [],
    get: [],
    create: [],
    update: [],
    patch: [],
    remove: []
  },

  error: {
    all: [],
    find: [],
    get: [],
    create: [],
    update: [],
    patch: [],
    remove: []
  }
};
