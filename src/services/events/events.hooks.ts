import * as authentication from '@feathersjs/authentication';
import { Forbidden } from '@feathersjs/errors';
import { HookContext } from '@feathersjs/feathers';
import { EventServiceForbidden } from '../../errors/events/event.service.forbidden.error';
import { ZeroEvent } from '../../errors/events/zero.event';
// Don't remove this comment. It's needed to format import lines nicely.

const { authenticate } = authentication.hooks;


/*
  Controling the Event service access 
  According to the exercice we should not be able to update or delete envents
*/
const controlEnventServiceAcces = () => {

  return async (context: HookContext) => {
    const { method } = context;
    if (method === 'update' || method === 'patch'  || method === 'remove'){ 
        throw new EventServiceForbidden("This service is forbidden on this events service", method);
    }
    //returning the context as best practice
    return context;
  }
} 

/*
  Will be call before every create request on the Event service
  Formating the event's data accordingly to the event table strucure,  
  and integrating them in the Hook context for further processing
*/ 
const buildEventsDataToPersit = () => {
  
  return async (context: HookContext) => {

    const { app, data, params } = context;

    // Function to iterate on every consent object in the user's array of consent
    const formatEventToPersist = async (consent : any) => {
      // prepare the creation date of the event as recommended by the exercice
      const eventCreatedAt = new Date().getTime();
      // Building an event instance as it will be inserted accordingly to the "event" table structure. An event Id will be auto-generated by the database. 
      // A 'unique' constraint has been configure on the Sequelise schema of the table for the columns (created_at, userUuid, consent_label, consent_decision)
      return { 
          'createdAt': eventCreatedAt, 
          'userUuid': data.user.id, 
          'consentLabel': consent.id,
          'consentDecision': consent.enabled
      };
    }
    //The object listOfEventToPersist is to collect the list of event to persist in database for the current User
    let listOfEventToPersist : Array<any> = [];
    if(data.consents){
        if(data.consents.length > 0){
            listOfEventToPersist = await Promise.all( data.consents.map(formatEventToPersist) );
        }
        else{
            throw new ZeroEvent("At least one event is needed from the User", data);
        }
        context.data = listOfEventToPersist; 
    } 
    else{
        throw new ZeroEvent("No event has been sent by the User", data);
    }
    //returning the context as best practice
    return context;
  }
} 
 
  /*
    Will be call "after" every CRUD request on the Event service, before returning the event data to the API's client
  */
 const formatEventToDisplay = () => {

    return async (context: HookContext) => {

        const { result, method, app } = context;

        // Is use this fonction to transform an event from the event table structure to API client event structure
        const getFormattedListOfConsent = async ( event : any) => {
            //Will contain the list of consents relative to this event for the user, 
            let listOfConsents: Array<any> = [];
            // Get the list of consents registered at the same time as one event
            const listOfEvent = await app.service('events').getEventsByUserAndDate(event);
            // Format the list of event as the API client wants
            listOfEvent.forEach( (currentEvent: any) => {
               listOfConsents.push({
                   'id': currentEvent.consentLabel,
                    'enabled': currentEvent.consentDecision
               });
            });  
            return listOfConsents;  
        }
        // Is use this fonction to return the final template of an event, accordingly to the API client event structure
        const getFinalFormattedEvent =  ( Uuid: any, evenList: any[]) => {
            return context.result = {
                'user': {
                    'id': Uuid
                },
                'consents': evenList
            };  
        }

        if(method === 'find') {
          if(result.data){
              if(result.data.length > 0){
                 // Map all events from database to build the list of Event in the API client format 
                 // Limit the list of events to iterate : a list of event grouped by 'created_at' column
                 result.data = await app.service('events').getEventsGroupByCreatedAt();
                 let arrayOfFormattedEvents: any = [];
                 context.result = await Promise.all(result.data.map( async (currentGroupedEvent: any) =>{
                      const listOfConsents = await getFormattedListOfConsent(currentGroupedEvent);
                      return getFinalFormattedEvent(currentGroupedEvent.userUuid, listOfConsents);
                 }));
              }
          }
        }
        else {
            // Otherwise just deal wit the single event result accordingly to its consents, 
            // using only one of the consent in the event is sufficient to format the events to display
            const listOfConsents = await getFormattedListOfConsent(result[0]); 
            context.result = getFinalFormattedEvent(result[0].userUuid, listOfConsents);
        } 
  
        // We return the hook context
        return context;
    }
};


export default {
  before: {
    //All securized all web service with Jwt token
    //control the REST method before each incoming request, the exercice require not be let possible event update and delete
    all: [ authenticate('jwt'), controlEnventServiceAcces() ],
    find: [],
    get: [],
    //prepare our events data before storage into event table
    create: [ buildEventsDataToPersit() ],
    update: [],
    patch: [],
    remove: []
  },

  after: {
    all: [ formatEventToDisplay() ],
    find: [],
    get: [],
    create: [],
    update: [],
    patch: [],
    remove: []
  },

  error: {
    all: [],
    find: [],
    get: [],
    create: [],
    update: [],
    patch: [],
    remove: []
  }
};
